#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

/*-----------------------------------------------------------------------------------
* 문제 번호 | [bj1904] 01타일 (실버3)
* 소요 시간 | GG
* 체감 난이도 | COMPLETE FAILURE
* 
* 헤맨 이유 |
*	1. 어떤 규칙성이 있다는 건지 찾질 못했다.
*		'n번째 값이, 그 앞의 값들과 뭔가 연관이 있겠다-' 정도까지만 알았다.
*		(딱히 이유 없이) n이 짝수번째일 때/홀수번째일 때를 나눠 생각하면서에서부터 틀려먹은 듯.
*		담부턴 이유 있게 생각하자..^^
* 
* 접근했어야 하는 순서 |
*	1. 일단 n=1일 때, n=2일 때 정도는 계산해본다.
*	2. n=3일 때를 계산하려면,
*		- n=1인 경우(1)에 '00'을 추가하고,
*		- n=2인 경우(00, 11)에 '1'을 추가하면 되겠군.
*	3. Q. n=1인 경우, 00을 앞뒤에 추가해야 하나? (001, 100)
*		일단 그런 식으로 다 해보면
*		n=1에 00 추가 -> 001, 100
*		n=2에 1 추가 -> 100, 001, 111
*		겹치는 경우가 생기는 군? 안 겹치게 하려면 어떻게 해야 되지..
*	4. 00/1을 앞에만 추가해볼까?
*		n=1에 00 앞에만 추가 -> 001
*		n=2에 1 앞에만 추가 -> 100, 111
*		중복 없이 잘 됐다!
*	5. n=4일 때도 해볼까?
*		n=2에 00 앞에만 추가 -> 0000, 0011
*		n=3에 1 앞에만 추가 -> 1001, 1100, 1111
*	6. 아하 cnt(n) = cnt(n-2) + cnt(n-1) 이구나!
*	7. 1~n 사이즈를 갖는 배열 같은 데에 각 값을 순서대로 저장하면 되겠지?
*		동적으로 사이즈 조절 가능한 vector를 써야지!
*	8. 제출해보니 : n의 최대값이 1,000,000이라 그런지 시간/메모리 초과가 뜨네..?
*		n을 int로 받으면 안 되고, long long으로 받아야겠다.
*		cnt(n)을 15,746으로 나눈 나머지를 출력해야 하니,
*		애초에 데이터를 저장할 때, 미리 % 계산 해서 그 나머지 값을 저장하자!
------------------------------------------------------------------------------------*/

int main() {
	int n, i; // n 최대값 1,000,000
	long long temp;
	vector<long long> cnt = { 0, 1, 2 }; // n=1일때 1, n=2일 때 2
	
	cin >> n;

	for (i = 3; i <= n; i++) {
		temp = cnt[i - 2] + cnt[i - 1];
		cnt.push_back(temp % 15746);
	}

	printf("%d", cnt[n]);

	return 0;
}
